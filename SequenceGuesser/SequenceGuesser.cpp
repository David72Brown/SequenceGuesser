/*
Improvements to make:

Function main() should be able to initiate a search of a certain string length and using the most common operators etc, then if that fails it starts a new search using sqrt() etc
and the search must only try formulas which include the new operators and at the new extended length.

Add missing values, possibly multiple ones, giving the formula a bye for generating them. For each correct formula, use it to predict the missing value.
(Could be more than one possible answer if given series can be generated by different formulas.)

To predict next value after last given value, regard that as a "missing value" in that end position.

Need new operators:
	- Modulo - should be easy.
	- Accessing individual digits of previous values in series e.g. digits counted from least-sig digit or digits from most-sig.
	- Sum and Product operators (Sigma and Pi).

Once got timings recorded for various sequences, try changing S to be just another unary operator, "S", which operates on the last value on the stack.
*/

#include "stdafx.h"
#include <assert.h>
#include <math.h>
#include <random> // ^^^ Needed?
#include <time.h>
#include <chrono>

typedef enum { CONSTANT, S, I, OPERATOR, NUM_ITEM_TYPES } eItemType; // Don't change order.
#define INC_TYPE(x) x = static_cast<eItemType>(1 + static_cast<int>(x))

#define MAX_POSS_ITEMS_IN_EXPRESSION	20	// Beyond that and it would probably take a very long time.

static int EveryOtherFib[]		= { 1, 2, 5, 13, 34, 89, 233 };
static int Fibonacci[]			= { 1, 2, 3, 5, 8, 13, 21, 34, 55, 89 };
static int Hanoi[]				= { 1, 3, 7, 15, 31, 63, 127, 255, 511 };
static int Magic[]				= { 1, 36, 1225, 41616, 1413721, 48024900 };
static int DbleTriangles_i[]	= { 0, 2, 14, 84, 492, 2870 };						// i in Ti where 2Ti is Tj.
static int DbleTriangles_j[]	= { 0, 3, 20, 119, 696, 4059, 23660, 137903 };		// j in Tj where Tj is Ti / 2.

typedef double(*pOperatorFn) (double a, double b);
typedef struct {
	char		*Display;	// "+"
	int			NumOperands;
	pOperatorFn	pOpFunction;
	bool		Available;	// Whether we're using it in this attempt.
} sOperator;
double AddOpFn(double a, double b) { return a + b; }
double SubtractOpFn(double a, double b) { return a - b; }
double MultiplyOpFn(double a, double b) { return a * b; }
double DivideOpFn(double a, double b) { return a / b; }
double SquareOpFn(double a, double b) { return b * b; }
double CubeOpFn(double a, double b) { return b * b * b; }
double SqRootOpFn(double a, double b) { return sqrt(b); }
double DigitFromRightOpFn(double a, double b) { return int(a / pow(10, b)) % 10; }					// Digit 0 is units, 1 is tens, 2 is hundreds etc.
double DigitFromLeftOpFn(double a, double b) { return DigitFromRightOpFn(a, log10(a) - b); }	// Digit 0 is leftmost digit, 1 is next etc.

sOperator AddOp				= { "+", 2, AddOpFn };
sOperator SubtractOp		= { "-", 2, SubtractOpFn };
sOperator MultiplyOp		= { "*", 2, MultiplyOpFn };
sOperator DivideOp			= { "/", 2, DivideOpFn };
sOperator SquareOp			= { "^2", 1, SquareOpFn };
sOperator CubeOp			= { "^3", 1, CubeOpFn };
sOperator SqRootOp			= { "sqrt", 1, SqRootOpFn };
sOperator DigitFromRightOp	= { "rdigit", 2, DigitFromRightOpFn };
sOperator DigitFromLeftOp	= { "ldigit", 2, DigitFromLeftOpFn };

#define MAX_OP_CONSUMPTION 2 // The greatest number of operands any operator can take.
#define MAX_POSS_OPERATORS 20
sOperator *Operators[MAX_POSS_OPERATORS];

typedef struct {
	eItemType	ItemType;
	int			Index;
} sItem;

static int GetStackHeightIncrease(eItemType e, int Index)
{
	if (e == OPERATOR)
	{
		return 1 - Operators[Index]->NumOperands;
	}
	else
	{
		return 1;
	}
}

static bool CheckOperatorValidHere(sItem *Items, int NumItems)
{
	// There is no point testing certain sequences since they will be covered by other, equivalent sequences.
	if (NumItems >= 3)
	{
		if (Items[NumItems - 3].ItemType == OPERATOR && Items[NumItems - 2].ItemType != OPERATOR) // Assume Items[NumItems-1] is an operator because of the name of this fn.
		{
			/* Various combinations of operator operand operator can be skipped. E.g. +x+ = x++ so don't check since "+ operand +" since it will be checked later as "operand + +".
				+x+ = x++
				-x- = x+-
				*x* = x**
				dxd = x*d   'd' means division sign. I can't type it properly because the compiler will think it's a C++ comment.
				+x- = x-+
				-x+ = x--
				*xd = xd*
				dx* = xdd
			*/
			if (Operators[Items[NumItems - 3].Index]->pOpFunction == AddOpFn || Operators[Items[NumItems - 3].Index]->pOpFunction == SubtractOpFn)
			{
				if (Operators[Items[NumItems - 1].Index]->pOpFunction == AddOpFn || Operators[Items[NumItems - 1].Index]->pOpFunction == SubtractOpFn)
					return false;
			}
			else if (Operators[Items[NumItems - 3].Index]->pOpFunction == MultiplyOpFn || Operators[Items[NumItems - 3].Index]->pOpFunction == DivideOpFn)
			{
				if (Operators[Items[NumItems - 1].Index]->pOpFunction == MultiplyOpFn || Operators[Items[NumItems - 1].Index]->pOpFunction == DivideOpFn)
					return false;
			}
		}
		if ((Operators[Items[NumItems - 1].Index] == &AddOp && MultiplyOp.Available)	// xx+ = x2*
			|| (Operators[Items[NumItems - 1].Index] == &MultiplyOp && SquareOp.Available))	// xx* = x squared
		{
			if (Items[NumItems - 3].ItemType != OPERATOR
			 && Items[NumItems - 3].ItemType == Items[NumItems - 2].ItemType
			 && Items[NumItems - 3].Index == Items[NumItems - 2].Index)
			{
				return false;
			}
		}
		// CONSTANT CONSTANT + [or - or *] (since equals a different constant)
		if (Items[NumItems - 3].ItemType == CONSTANT && Items[NumItems - 2].ItemType == CONSTANT
		&&	 (Operators[Items[NumItems - 1].Index] == &AddOp
		   || Operators[Items[NumItems - 1].Index] == &SubtractOp
		   || Operators[Items[NumItems - 1].Index] == &MultiplyOp))
		{
			return false;
		}
		// OPERAND SAME_OPERAND /      e.g. 5 5 / would be 5 divided by 5 = 1.
		if (Items[NumItems - 3].ItemType != OPERATOR && Items[NumItems - 2].ItemType == Items[NumItems - 3].ItemType
		 && Items[NumItems - 3].Index == Items[NumItems - 2].Index
		 && Operators[Items[NumItems - 1].Index] == &DivideOp)
		{
			return false;
		}
		// Should rule out one of ab+ and ba+ (and for *).
		// When we get to ba+ we know that ab+ will already have been done. Ordering of a and b is known from their item type and indices.
		if (Items[NumItems - 3].ItemType != OPERATOR
			&& Items[NumItems - 2].ItemType != OPERATOR
			&& (Operators[Items[NumItems - 1].Index] == &AddOp || Operators[Items[NumItems - 1].Index] == &MultiplyOp)
			&& (Items[NumItems - 3].ItemType > Items[NumItems - 2].ItemType || (Items[NumItems - 3].ItemType == Items[NumItems - 2].ItemType
				&& Items[NumItems - 3].Index > Items[NumItems - 2].Index)))
		{
			return false;
		}
		if (NumItems >= 4)
		{
			// OPERAND + SAME_OPERAND - [or swap + and -]
			// OPERAND * SAME_OPERAND / [or swap * and /]
			if (Items[NumItems - 4].ItemType != OPERATOR && Items[NumItems - 4].ItemType == Items[NumItems - 2].ItemType
				&& Items[NumItems - 4].Index == Items[NumItems - 2].Index)
			{
				if ((Operators[Items[NumItems - 3].Index] == &AddOp && Operators[Items[NumItems - 1].Index] == &SubtractOp)
					|| (Operators[Items[NumItems - 1].Index] == &AddOp && Operators[Items[NumItems - 3].Index] == &SubtractOp))
				{
					return false;
				}
				if ((Operators[Items[NumItems - 3].Index] == &MultiplyOp && Operators[Items[NumItems - 1].Index] == &DivideOp)
					|| (Operators[Items[NumItems - 1].Index] == &MultiplyOp && Operators[Items[NumItems - 3].Index] == &DivideOp))
				{
					return false;
				}
			}
		}
	}
	// Do this one last because it applies to the little-used square and sqrt ops so more efficient to check common ops above first.
	if (NumItems >= 2)
	{
		// sq sqrt or vice versa.
		if (Items[NumItems - 2].ItemType == OPERATOR
			&& ((Operators[Items[NumItems - 2].Index] == &SquareOp && Operators[Items[NumItems - 1].Index] == &SqRootOp)
				|| (Operators[Items[NumItems - 1].Index] == &SquareOp && Operators[Items[NumItems - 2].Index] == &SqRootOp)))
		{
			return false;
		}
	}
	return true;
}

static void SpitFormula(sItem Items[], int NumItems)
{
	int inum;

	for (inum = 0; inum < NumItems; inum++)
	{
		switch (Items[inum].ItemType)
		{
		case OPERATOR:
			printf(" %s", Operators[Items[inum].Index]->Display);
			break;
		case CONSTANT:
			printf(" %d", Items[inum].Index + 1);
			break;
		case I:
			printf(" i");
			break;
		case S:
			printf(" S(i-%d)", Items[inum].Index + 1);
			break;
		default:
			assert(false);
		}
	}
	printf("\n");
}

static bool GuessSequence (int Seq[], int SeqLen,	int MinItemsInExpression,	// 1+2*3 makes 5 items.
													int MaxItemsInExpression,
													int NumOperators,
													int MaxRetroS,				// How far back in the sequence you look. MaxRetroS == x means back as far as S(i-x).
													int NumConstants)			// I.e. we use 1, 2, 3 in expressions. NumConstants == 9 means we can use all 9 constants 1-9.
{
	// NumIndexValsForItem[] assumes the order of item types in eItemType. Not good coding but lends itself to this very fast method using a look-up table. The order is asserted in main().
	static int NoIndexForI = 0;
	static int* NumIndexValsForItem[NUM_ITEM_TYPES] = {
		&NumConstants,	// CONSTANT. See block comment above.
		&MaxRetroS,		// S. See block comment above.
		&NoIndexForI,	// I => index not used.
		&NumOperators	// OPERATOR.
	};
	sItem Items[MAX_POSS_ITEMS_IN_EXPRESSION];
	int StackHeight, sh, NumItems, i, inum;
	bool KeepChecking, ByeIntoNextInSeq, ItemValid, Ready;
	double NewNum;
	double Stack[MAX_POSS_ITEMS_IN_EXPRESSION];
	bool Success;
	eItemType NewItemType;

	assert(NumOperators >= 1 && MinItemsInExpression >= 1 && MaxItemsInExpression <= MAX_POSS_ITEMS_IN_EXPRESSION);

	StackHeight = 0;
	NumItems = 0;

	// When we want to tack another item onto the end of the string, what is that item? Probably a constant but if no constants in use in this
	// attempt then it could be something else.
	if (NumConstants >= 1)
	{
		NewItemType = CONSTANT;
	}
	else if (MaxRetroS >= 1)
	{
		NewItemType = S;
	}
	else
	{
		NewItemType = I;
	}

	for (Success = false, ItemValid = true; ; )
	{
		// Enlarge the expression.
		if (ItemValid && NumItems < MaxItemsInExpression)
		{
			Items[NumItems].ItemType = NewItemType;
			Items[NumItems].Index = 0;
			NumItems += 1;
			StackHeight += GetStackHeightIncrease(Items[NumItems - 1].ItemType, Items[NumItems - 1].Index);
		}
		else
		{
			ItemValid = true;
			for (Ready = false; !Ready; )
			{
				Ready = true;
				StackHeight -= GetStackHeightIncrease(Items[NumItems - 1].ItemType, Items[NumItems - 1].Index);
				if (Items[NumItems - 1].Index < *NumIndexValsForItem[Items[NumItems - 1].ItemType] - 1)
				{
					Items[NumItems - 1].Index += 1;
				}
				else
				{
					// Already at last index for this item type so go to next type.
					if (Items[NumItems - 1].ItemType < NUM_ITEM_TYPES - 1)
					{
						INC_TYPE(Items[NumItems - 1].ItemType);
						Items[NumItems - 1].Index = 0;
					}
					else
					{
						// Already at last type so go back to previous item.
						if (NumItems == 1)
						{
							// Already come all the way back to first item and exhausted it, so finish.
							return Success;
						}
						NumItems -= 1;
						Ready = false;
					}
				}
			}
			StackHeight += GetStackHeightIncrease(Items[NumItems - 1].ItemType, Items[NumItems - 1].Index);
		}
		// Need to set ItemValid indicating whether this item can go here, with or without needing further items after it to create a valid formula,
		// E.g. S(i) = 1 i    is not worth checking because a valid solution would need to end up with a stack height of 1, but the 'i' is valid because
		//                    this formula might go on to become S(i) = 1 i +
		if (Items[NumItems - 1].ItemType != OPERATOR)
		{
			// If just added an operand, check stack height isn't so high that we can't come down to 1 by end of expression.
			ItemValid = StackHeight - (MaxItemsInExpression - NumItems) * (MAX_OP_CONSUMPTION - 1) <= 1;
			if (!ItemValid)
			{
				// If stack too high to take another operand, no point just trying another operand so skip them and go to the operators.
				StackHeight -= GetStackHeightIncrease(Items[NumItems - 1].ItemType, Items[NumItems - 1].Index);
				Items[NumItems - 1].ItemType = OPERATOR;
				Items[NumItems - 1].Index = 0;
				StackHeight += GetStackHeightIncrease(OPERATOR, 0);
				// Check for combinations which would be checked for at some other point.
				ItemValid = CheckOperatorValidHere(Items, NumItems);
			}
		}
		else if (Items[NumItems - 1].ItemType == OPERATOR)
		{
			// If just added an operator, check we have enough operands already on the stack for it to operate on.
			ItemValid = StackHeight >= Operators[Items[NumItems - 1].Index]->NumOperands;
			ItemValid = ItemValid && CheckOperatorValidHere(Items, NumItems);
		}
		if (ItemValid && StackHeight == 1 && NumItems >= MinItemsInExpression)
		{
			// This might now equal S(i). Evaluate if expression true for all i.
			KeepChecking = true;
			for (i = 0; KeepChecking && i < SeqLen; i++)
			{
				sh = 0;
				for (ByeIntoNextInSeq = false, inum = 0; !ByeIntoNextInSeq && inum < NumItems; inum++)
				{
					switch (Items[inum].ItemType)
					{
					case OPERATOR:
						NewNum = Operators[Items[inum].Index]->pOpFunction(Stack[sh - 2], Stack[sh - 1]);
						sh -= Operators[Items[inum].Index]->NumOperands;
						Stack[sh] = NewNum;
						sh += 1;
						break;
					case CONSTANT:
						Stack[sh] = Items[inum].Index + 1;
						sh += 1;
						break;
					case I:
						Stack[sh] = i;
						sh += 1;
						break;
					case S:
						if (i > Items[inum].Index)
						{
							Stack[sh] = Seq[i - Items[inum].Index - 1];
							sh += 1;
						}
						else
						{
							// Can't refer to S(i-3) if we're only 1 step into the sequence.
							// Skip this but keep checking rest of sequence.
							ByeIntoNextInSeq = true;
						}
						break;
					default:
						assert(false);
					}
				}
				if (!ByeIntoNextInSeq && Stack[0] != Seq[i])
				{
					KeepChecking = false;
				}
			}
			if (KeepChecking)
			{
				// Found solution.
				printf("Next sol:  ");
				SpitFormula(Items, NumItems);
				Success = true;
			}
		}
	}
	return Success;
}

static unsigned int NoteTime(void)
{
	std::chrono::system_clock::time_point TimeNow;
	static time_t Last_tt, Next_tt;
	double Diff_tm;
	static bool BeenHereBefore = false;

	if (!BeenHereBefore)
	{
		TimeNow = std::chrono::system_clock::now();
		Last_tt = std::chrono::system_clock::to_time_t(TimeNow);
		BeenHereBefore = true;
		return 0;
	}
	TimeNow = std::chrono::system_clock::now();
	Next_tt = std::chrono::system_clock::to_time_t(TimeNow);
	Diff_tm = difftime(Next_tt, Last_tt);
	Last_tt = Next_tt;
	return (unsigned int)Diff_tm;
}

int main()
{
	int a, NumOperators;
	bool Success;
	unsigned int ElapsedTime;

	// NumIndexValsForItem[] assumes the order of item types in eItemType. Not good coding but lends itself to this very fast method using a look-up table.
	// The order is asserted in here.
	assert(CONSTANT == 0 && S == 1 && I == 2 && OPERATOR == 3 && NUM_ITEM_TYPES == 4);

#define Seq Fibonacci

	struct {
		int MinItemsInExpression;
		int MaxItemsInExpression;
		sOperator *Operators[MAX_POSS_OPERATORS];
		int MaxRetroS;	// S => x in S(i-x).
		int NumConstants; // 3 means we can use 1, 2 and 3. We never need 0 in a formula.
	} Attempts[] = {
		// Start off with short strings and most likely operators, then check longer strings and more ops on later attempts.
		{
			1, 3,
			{ &AddOp },
			2,
			1
		},
		{
			1, 3,
			{ &AddOp, &SubtractOp },
			2,
			2
		},
		{
			4, 5,
			{ &AddOp, &SubtractOp, &MultiplyOp, &DivideOp },
			2,
			9
		},
		{
			1, 10,
			{ &AddOp, &SubtractOp, &MultiplyOp, &DivideOp, &SquareOp },
			2,
			1
		},
		{
			1, 7,
			{ &AddOp, &SubtractOp, &MultiplyOp, &DivideOp },
			2,
			2
		},
		{
			1, 12,
			{ &AddOp, &SubtractOp, &MultiplyOp, &DivideOp, &SquareOp },
			2,
			5
		},
		{
			1, 20,
			{ &AddOp, &SubtractOp, &MultiplyOp, &DivideOp, &SquareOp, &CubeOp, &SqRootOp },
			4,
			9
		},
		{
			1, 20,
			{ &AddOp, &SubtractOp, &MultiplyOp, &DivideOp, &SquareOp, &CubeOp, &SqRootOp, &DigitFromLeftOp, &DigitFromRightOp },
			5,
			9
		}
	};

	for (a = 0; a < sizeof(Attempts) / sizeof(Attempts[0]); a++)
	{
		for (NumOperators = 0; NumOperators < MAX_POSS_OPERATORS && Attempts[a].Operators[NumOperators]; NumOperators++)
		{
			Operators[NumOperators] = Attempts[a].Operators[NumOperators];
			Operators[NumOperators]->Available = true;
		}
		if (NumOperators < MAX_POSS_OPERATORS)
			Operators[NumOperators] = nullptr;
		printf("Attempt number %d...\n", a);
		NoteTime();
		Success = GuessSequence(Seq, sizeof(Seq) / sizeof(int), Attempts[a].MinItemsInExpression, Attempts[a].MaxItemsInExpression, NumOperators, Attempts[a].MaxRetroS, Attempts[a].NumConstants);
		ElapsedTime = NoteTime();
		if (Success)
		{
			printf("Attempt %d succeeded after %02d:%02d:%02d.\n", a, ElapsedTime / 3600, ElapsedTime / 60 % 60, ElapsedTime % 60);
			break;
		}
		else
		{
			printf("...Attempt number %d failed after %02d:%02d:%02d.\n", a, ElapsedTime / 3600, ElapsedTime / 60 % 60, ElapsedTime % 60);
		}
	}
	return 0;
}
